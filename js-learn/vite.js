cd ~/projects

cd C:/шлях/до/папки/projects   //для Windows
cd /шлях/до/папки/projects     //для macOS

npm create vite@latest

cd назва проєкту

code .

npm install  або   npm i
    
// NPM завантажує з реєстру всі залежності, зазначені у файлі package.json у властивостях dependencies (якого в нас ще немає) і devDependencies, і поміщає їх у папку node_modules у корені проєкту, в якій перебуватимуть усі залежності.

npm run[script - name]
npm run dev - starts a live page

ctrl + c   for closing and writing in terminal again

npm i[package - name]
f.e.: npm i validator   щоб встановити бібліотеку vite

npmjs.com 

у файлі java script:

import [name] from "script"   script is in package.json in "dependencies"
import validator from "validator"

npm uninstal[package - name]
npm r[package - name]

// Так само і з залежностями проєкту: деякі будуть використані у фінальному продукті, інші необхідні тільки на стадії розробки.

// Саме для цього команди npm install і npm uninstall мають два прапорці.

--save //— вказує, що додається залежність, яка увійде до фінального продукту. Пакет буде встановлений локально, в папку node_modules, і буде доданий запис у поле dependencies в package.json.
--save - dev //— вказує, що додається залежність розробки, яка не увійде до фінального продукту. Пакет буде встановлений локально, в папку node_modules, і буде доданий запис у поле devDependencies в package.json.

export default function makeMessage(username) {
	return `Welcome, ${username}!`;
}

import makeMessage from "./makeMessage";

console.log(makeMessage("Jacob")); // "Welcom, Jacob!"


// Основна ідея полягає в тому, що в одному модулі може бути лише один експорт за замовчуванням (default export). Це значення вважається "головним" значенням модуля, коли його імпортують в інші частини коду.

// Операція експорту за замовчуванням реалізована конструкцією export default.

export default exportedValue

// export default — ключова фраза для експорту;
// exportedValue — значення, яке експортується.

const makeMessage = username => {
    return `Welcome, ${username}!`
}

export default makeMessage;


// Операція імпорту за замовчуванням реалізована конструкцією import.

    import name from "..."

// import і from — ключові фрази для імпорту;
// name — локальна змінна, в яку імпортується значення;
// "..." — відносний шлях до файлу модуля у вигляді рядка.

// У будь-якому іншому файлі проєкту можна імпортувати значення за замовчуванням.

import makeMessage from "./makeMessage";
console.log(makeMessage("Jacob")); // "Welcom, Jacob!"

// Зверни увагу, що ім'я, з яким імпортується значення за замовчуванням, може бути вибрано довільним чином.

// Використання експорту за замовчуванням зручне, коли тобі потрібно експортувати одне головне значення з модуля, наприклад, основну функцію або об'єкт.

// Операція іменованого експорту реалізована конструкцією з export.

export const makeMessage = username => {
    return `Hello, ${username}!`;
}

export const levels = ['easy', 'medium', 'hard'];

// Кількість іменованих експортів в одному модулі не обмежена, на відміну від експорту за замовчуванням, який може бути тільки один.

// Операція іменованого імпорту реалізована конструкцією з import.

import { name } from "..."

// import — вказує на суть операції;
//  from — на шлях до модуля з імпортованою сутністю;
// name — ім'я змінної, яке повинно збігатися з іменем експорту в модулі;
// "..." — шлях до файлу модуля у вигляді рядка.

// У будь-якому іншому файлі проєкту можна імпортувати конкретні елементи з іншого файлу (модуля), використовуючи їх імена в конструкції іменованого імпорту.

import { makeMessage, levels } from "./makeMessage";

console.log(makeMessage("Jacob")); // "Welcom, Jacob!"
console.log(levels); // ["easy", "medium", "hard"]

// Rename export — це техніка, яка дозволяє імпортувати іменовані експортовані змінні, функції тощо з одного модуля до іншого, змінюючи їм ім’я під час імпорту.

// Щоб задати нове ім'я під час імпорту з іншого модуля, використовується ключове слово as.

import { name as newName } from '...'

// Коли використовувати перейменування?
// У бібліотеках або в інших модулях імена можуть бути довгими, досить загальними або конфліктувати з іменами змінних у твоєму поточному модулі. У цих випадках доцільно використовувати перейменування для зручності та уникнення конфліктів.


// Імпорт простору імен (namespace import) — це техніка імпортування всього вмісту модуля як об'єкта з іменем, що представляє простір імен цього модуля. Це означає, що всі іменовані експорти з модуля стають властивостями цього об'єкта. Це зручно, коли потрібно імпортувати багато різних функцій, змінних або класів з модуля, не обираючи їх по одному.