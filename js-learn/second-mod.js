// Інструкція if дозволяє виконати певний блок коду тільки в тому випадку, якщо задана умова істинна (тобто приймає значення true).
// Загальний синтаксис інструкції if виглядає так:



if (condition) {
  // код, який виконується, якщо умова (condition) істинна
}



// Коли інтерпретатор зустрічає інструкцію if, він обчислює вказану умову в круглих дужках (condition), перетворюючи її до логічного типу (boolean).
// Якщо умова (condition) перетворюється до true, виконується блок коду, написаний у фігурних дужках {} — (statement).
// Якщо умова (condition) перетворюється до false, блок коду не виконається і продовжиться виконання програми, що іде після інструкції if.


let price = 100;
const planeClass = "first" //or 'economy';

if (planeClass === "first") {
    price = 1500;
}

console.log(price); //якщо умова виконується, то ціна - 1500. якщо ні - 100

// Інструкція if...else
// Синтаксис інструкції if можна доповнити блоком else для визначення альтернативних варіантів виконання коду.

if (condition) {
  // код, який виконується, якщо умова істинна
} else {
	// код, який виконується, якщо умова хибна
}


const grade = 6;

if (grade >= 9) {
     console.log(`You are in high school`);
} else {
    console.log(`You are in middle school`);
}


// Конструкція else...if розширює конструкцію if...else і дозволяє перевірити та зреагувати на виконання або невиконання кількох умов. Це корисно, коли ми маємо більше однієї умови.

if (condition_1) {
  // код, який виконується, якщо умова (condition_1) істинна
} else if (condition_2) {
  // код, який виконується, якщо умова (condition_2) істинна
} else if (condition_3) {
  // код, який виконується, якщо умова (condition_3) істинна
} else {
	// код, який виконується, якщо всі умови хибні
}

// Якщо умова condition_1 істинна, виконується відповідний блок коду, і перевірка завершується.
// Якщо умова condition_1 хибна, то перевіряється умова_2 і далі.
// Код у блоці else буде виконаний тільки у випадку, якщо жодна з умов у блоках if та else if не є істинною.

const rate = 4;

if (rate === 5) {
    console.log("You american grade would be an A!");
} else if (rate === 4) {
    console.log("You american grade would be a B!");
} else if (rate === 3) {
    console.log("You american grade would be a C!");
}
else if (rate === 2) {
    console.log("You american grade would be a D!");
}
else if (rate === 1) {
    console.log("You american grade would be a F!");
}


// Тернарний оператор — це коротша синтаксична заміна інструкції if...else. Тернарний оператор дозволяє виконувати певну частину коду залежно від умови.

// <condition> ? <expression if condition is true> : <expression if condition is false>
// Він працює таким чином:
// обчислюється умова condition;
// якщо умова істинна (перетворюється до true), обчислюється вираз після ?;
// якщо умова хибна (перетворюється до false), обчислюється вираз після :;
// значення обчисленого виразу повертається як результат роботи тернарного оператора.

let type;
const age = 20;

if (age >= 18) {
  type = 'adult';
} else {
  type = 'child';
}

console.log(type); // 'adult'

// через тернарний оператор буде виглядати так:

const Age = 20;
const Type = Age >= 18 ? 'Adult' : 'Child';


// const a = 5;
// const b = 10;
// let biggerNumber;

// if (a > b) {
//   biggerNumber = a;
// } else {
//   biggerNumber = b;
// }

// console.log(biggerNumber); // 10

const a = 5;
const b = 10;
const biggerNumber = a > b ? a : b;
console.log(biggerNumber);

// Тернарний оператор рекомендується використовувати у найпростіших випадках операції присвоєння чи повернення. Однак не рекомендується використовувати його для складних розгалужень, оскільки це може ускладнити читання та розуміння коду.

function checkPassword(password) {
  const correctPassword = "jqueryismyjam";
 return password === correctPassword ? "Access granted" : "Access denied, wrong password!";
}


// загальний синтаксис оператора switch:

switch (expression) {
  case value1:
    // код, що виконується, якщо вираз (expression) дорівнює value1
    break;
  case value2:
    // код, що виконується, якщо вираз (expression) дорівнює value2
    break;
  // ...
  default:
    // код, що виконується, якщо вираз (expression) не відповідає жодному значенню
}

// Вираз (expression) в операторі switch обчислюється.
// Значення виразу порівнюється з кожним блоком case зверху вниз.
// Якщо значення виразу відповідає значенню в блоці case, виконується код цього блоку.
// Коли виконання коду блоку case завершено, необхідно використовувати оператор break, щоб вийти зі switch. Це запобігає виконанню коду в наступних блоках case.
// Якщо жодне значення не відповідає виразу, виконається код у блоці default (якщо він є).

const fruit = 'banana';
switch (fruit) {
    case 'apple':
        console.log('apple chosen');
        break;
    case 'banana':
        console.log('banana chosen');
        break;
    case 'pear':
        console.log('pear chosen');
        break;
    default:
        console.log('the fruit is not chosen');
}


// Із прикладу видно, що застосування switch обмежене завданнями з одним загальним питанням(що порівнювати) та безліччю варіантів відповідей(з чим порівнювати).

// Вираз у блоці switch — вираз будь - якого типу(змінна чи складні обчислення), результат якого послідовно зверху вниз, суворо порівнюється(===) з усіма значеннями в блоках case. Тобто не можна порівняти на більше чи менше, лише на сувору рівність.

// Оператор break додається наприкінці кожного блоку case. Функція оператора break — перервати подальші перевірки й відразу перейти до коду, що йде після switch, щойно виконався якийсь із блоків case.

// Якщо жодного збігу значень не відбулося, необхідно виконати код за замовчуванням.Для цього в кінці після всіх блоків case додається блок default.

// Оператор break після блоку default не потрібен, тому що це і так останнє, що буде виконано у switch і управління буде передано коду за ним.


// Якщо break не вказано, виконання коду продовжиться в наступному case і далі. Така поведінка називається "провалюванням" (fall-through). Якщо потрібно, щоб кілька блоків case виконували той самий код, можна опустити оператор break між ними.

const day = 4;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        console.log('Working day');
        break;
    case 6:
    case 7:
        console.log('Weekend');
        break;
    default:
        console.log('invalid');
}

// У цьому прикладі кілька блоків (case 1, case 2, case 3, case 4, case 5) провалюються і у випадку їх рівності виразу виконається один і той самий код, тому що між ними немає операторів break.


function getSubscriptionPrice(type) {
  switch (type) {
    case "starter":
  return 0;
      break;
    case "professional":
      return 20;
      break;
    case "organization":
      return 50;
      break;
    default:
      return "Invalid subscription type!";
  }
}


// Інструкція if є універсальною.Інструкції if…else і else…if використовуються, коли потрібно прописати декілька умов.Отже, ці інструкції зазвичай довші, ніж інші способи розгалужень.

// Тернарний оператор краще використовувати для присвоєння або повернення значення з тіла функції. В умові тернарного оператора може бути все що завгодно: перевірка рівності / нерівності, на більше / менше, просто перевірка на будь чого.

// Пам’ятай про обмеження: у нього має бути рівно 2 сценарії, не більше.

// Оператор switch перевіряє тільки на сувору рівність.

// Використовуючи оператор switch, завжди:
// — пам’ятай про оператор break;
// — використовуй тільки 1 default, він завжди має бути останнім.



// Область видимості визначає, чи будуть змінні та функції доступними в певних областях коду. Під час оголошення змінної або функції, вона стає "видимою" тільки в певній частині коду. Це впливає на те, де і як можна використовувати ці змінні та функції в коді.

// Змінні або функції, які оголошені поза будь-якими блоками коду — тобто в глобальній області видимості — будуть доступні в будь-якій частині коду. Вони є глобальними змінними.

// Глобальна змінна
const value = "I'm a global variable";

if (true) {
	// Можна звернутися до глобальної змінної
  console.log(value); // "I'm a global variable"
}

// Можна звернутися до глобальної змінної
console.log(value); // "I'm a global variable"



// Будь-яка конструкція, що використовує фігурні дужки {} (умови, функції, цикли тощо) створює нову локальну блочну область видимості. Змінні, оголошені в цій області видимості, можуть бути використані тільки всередині цього блоку коду. Це локальні змінні.
if (true) {
  // Локальна змінна
	const value = "I'm a local variable";
  console.log(value); // "I'm a local variable"
}

// Помилка: локальну змінну не видно за межами блоку
console.log(value); // ReferenceError: value is not defined

// Змінна value оголошена в тілі інструкції if, тобто в локальній області видимості, обмеженій тілом блоку if. Ця змінна буде доступна лише всередині блоку if, і спроба звернення до неї поза блоком if викликає помилку.



const globalVar = "Global";

console.log(globalVar); // Доступ до globalVar з глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const aVar = "A";
	console.log(globalVar); // Доступ до globalVariable з блоку A
  console.log(aVar); // Доступ до aVar з блоку A
	// Немає доступу до bVar і cVar

	if(true) {
		const bVar = "B";
		console.log(globalVar); // Доступ до globalVariable з блоку B
	  console.log(aVar); // Доступ до aVar з блоку B
	  console.log(bVar); // Доступ до bVar з блоку B
		// Немає доступу до cVar
	}
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar

if(true) {
	const cVar = "C";
  console.log(globalVariable); // Доступ до globalVar з блоку C
  console.log(cVar); // Доступ до cVar з блоку C
	// Немає доступу до aVar і bVar
}

console.log(globalVar); // Доступ до globalVar із глобальної області видимості
// Немає доступу до aVar, bVar і cVar



// Логічне перетворення типів означає приведення значення будь-якого типу даних у логічне (булеве) значення true або false. Існує кілька правил, які визначають, які значення перетворюються на true, а які на false.

// Ці правила працюють:

// як для явного перетворення типів за допомогою функції Boolean(),
// так і для неявного в умовних операціях, наприклад, у конструкціях if чи логічних операторах.

// Число 0, значення NaN, null і undefined завжди перетворюються на false. Усі інші числа перетворюються на true.

console.log(Boolean(Nan)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(3.14)); // true
console.log(Boolean(-10)); // true




if(null) {
	console.log("Block if")
} else {
	console.log("Block else")
}

if(0) {
	console.log("Block if")
} else {
	console.log("Block else")
}
// Значення в умові інструкцій if приводиться до false. Отже, виконується код із блоку else.


if(5) {
	console.log("Block if")
} else {
	console.log("Block else")
}
// Значення в умові інструкції if приводиться до true. Отже, виконується код із блоку if.

// Порожній рядок ("") приводиться до false. Будь-які інші не пусті рядки приводяться до true.
console.log(Boolean("")); // false
console.log(Boolean("hello")); // true
console.log(Boolean("false")); // true



// Запам’ятай 6 випадків, які приводяться до false:
// 1. 0
// 2. ""
// 3. Nan
// 4. null
// 5. underfined
// 6. false


// Оператор "І" (&&) наводить усі операнди до логічного типу (true або false) і повертає значення одного з них. Дозволяє перевірити, чи виконані всі умови у виразі.

expression1 && expression2


// Оператор “І” зліва направо перевіряє почергово обидва операнди на істинність та повертає або значення останнього істинного (тільки правого) операнда, або першого хибного (лівого чи правого), на якому він запнувся.

console.log("hello" && 5); // 5
console.log(5 && "hello"); // "hello"

console.log("mango" && "poly"); // "poly"
console.log("poly" && "mango"); // "mango"

console.log(3 && true); // true
console.log(true && 3); // 3



console.log("hello" && 0); // 0
console.log(0 && "hello"); // 0

console.log(3 && false); // false
console.log(false && 3); // false

console.log(0 && ""); // 0
console.log("" && 0); // ""

// У прикладі “hello” && 0 лівий операнд приводиться до true, а правий до false, тому результатом виразу буде значення правого операнда, який першим був приведений до false, тобто 0.
// У приклад 0 && “hello” лівий операнд приводиться до false, тому правий операнд не буде обчислюватися. Результатом виразу буде значення лівого операнда, який першим був приведений до false, тобто 0.

// На практиці логічні операції застосовуються для перевірки множинних умов.

const x = 20;
console.log(x > 10 && x < 30); // true && true -> true

const y = 50;
console.log(y > 10 && y < 30); // true && false -> false
console.log(y > 80 && y < 120); // false && true -> false



const screenWidth = 700;
const sm = 320;
const md = 768;
const lg = 1200;

if (screenWidth <= sm) {
    console.log("Mobile");
} else if (screenWidth > sm && screenWidth <= md) {
    console.log("Tablet");
} else if (screenWidth > md && screenWidth <= lg) {
    console.log("Desktop");
} else {
    console.log("Godzilla");
}

// Спочатку перевіряється умова if, тобто 700 < 320, вона повертає false, тому тіло блоку if ігнорується і виконання коду переходить далі до блоку else...if.

// У ньому є умова screenWidth > sm && screenWidth ≤ md.

// Спочатку обчислиться лівий операнд, умова 700 > 320 , яка поверне true , потім правий — 700 <= 768 , який теж поверне true.

// Оскільки обидва операнди істинні, то true && true поверне значення крайнього істинного операнда, тобто true . Завдяки тому, що в умові інструкції else...if буде true, виконається її тіло і в консоль виведеться рядок “Tablet screen”

function isNumberInRange(start, end, number) {
  if (number >= start && number <= end) {
    return true;
  } else {
    return false;
  }
}



// Оператор "АБО" (||) перетворює всі операнди до логічного типу (true або false) і повертає значення одного з них. Дозволяє перевіряти, чи є хоча б один із операндів "істинним”. Обчислення оператора відбувається зліва направо.
// Якщо хоча б один із операндів можна перетворити на true, результатом логічного «АБО» буде цей операнд.

console.log(true || false); // true
console.log(false || true); // true

console.log(5 || false); // 5
console.log(false || 5); // 5

console.log("hello" || 0); // "hello"
console.log(0 || "hello"); // "hello"

// Як тільки логічний оператор “АБО” знайшов операнд, який перетворюється на true, він зупиняється та повертає його значення. Якщо до істини було перетворено перший операнд, то другий навіть не буде оцінюватися. Це може мати практичне застосування, особливо коли другий операнд є виразом, який має високу вартість обчислення.

console.log(5 || 3); // 5
console.log(3 || 5); // 3

console.log("mango" || "poly"); // "mango"
console.log("poly" || "mango"); // "poly"

// Якщо всі операнди перетворюються на false, результатом буде значення крайнього правого операнда.

console.log(0 || false); // false
console.log(false || 0); // 0

console.log(null || ""); // ""
console.log("" || null); // null

// На практиці оператор «АБО» також використовується для перевірки множинних умов.

const q = 5;
console.log(q < 10 || q > 30); // true || false -> true

const w = 50;
console.log(w < 10 || w > 30); // false || true -> true

const c = 20;
console.log(c - 20 || c * 2); // 0 || 40 -> 40

// const screenWidth = 700;
// const sm = 320;
// const md = 768;
// const lg = 1200;

if(screenWidth <= sm || screenWidth > md) {
	console.log("Mobile or Desktop screen");
  // у консолі буде пусто, оскільки жодна з умов не перетворилась на true
}


// Усі оператори, які ми розглядали раніше, були бінарними. Бінарні оператори містять два операнди: лівий і правий.
// Логічне «НІ» (!) — це унарний оператор — він виконує операцію над одним операндом праворуч.

!expression

// Логічне «НІ» приводить операнд до логічного значення (true або false) і потім заперечує (інвертує) його, тобто заміняє на протилежне: true —> false, а false —> true.

console.log(!true); //false
console.log(!false); //true
console.log(!3); // !3 -> !true -> false
console.log(!"Mango"); // !"Mango" -> !true -> false
console.log(!0); // !0 -> !false -> true
console.log(!""); // !"" -> !false -> true
console.log(!null); // !null -> !false -> true

// На практиці логічне заперечення використовується для перевірки від зворотного. Наприклад, можна дозволити написати повідомлення в чаті, лише якщо користувач не заблокований.

const isBlocked = false;
const canChat = !isBlocked;
if (canChat) {
    console.log("You can chat");
} else {
    console.log("You are blocked");
    
}

// У прикладі вище бачимо, що значення змінної isBlocked — false . Користувач не заблокований. Результатом canChat буде true .
// Якщо значення змінної isBlocked — true, користувач заблокований. У такому разі результат обчислення canChat буде false. Отже, умова if заборонить користувачеві писати в чаті.

// Логічне заперечення можна поєднувати з іншими логічними операторами. Наприклад, якщо умова можливості писати в чаті залежить від статусу онлайн і блокування.

const isOnline = true;
const isblocked = false;
const allowed = isOnline && !isblocked;
// true && !false -> true && true -> true
if (canChat) {
    console.log("you are allowed");
} else {
    console.log("blocked");
}


function toggleModalVisibility(isVisible) {
  return !isVisible;
}



// Щоб добре розрізняти властивості та методи, варто згадати, що властивості — це описові характеристики сутності. У прикладі з кавою — це колір, кількість цукру, температура. Наприклад, у програмуванні рядок має властивість length, яка повертає кількість символів у рядку. Для доступу до властивості використовується синтаксис із крапкою:
objectName.property

const message = "JavaScript is awesome!";
console.log(message.length); //22


// Методи — це дії, які можна виконати із сутністю, такі як додати цукор чи підігріти. У програмуванні дані також заздалегідь мають певні методи, які дозволяють виконувати різні операції, наприклад, перетворення рядка в різний регістр.

// Виклик методу дуже схожий на доступ до властивості, але наприкінці додаються круглі дужки, як при виклику функції:

objectName.method()

// Ось приклад використання (виклику) методу toUpperCase() для перетворення рядка у верхній регістр:

const Message = "JavaScript is awesome!";
console.log(Message.toUpperCase()); // "JAVASCRIPT IS AWESOME!"

// Методи та властивості не можуть існувати самостійно без сутності, частиною якої вони є. Не можна викликати метод рядка trim() без рядка, не можна отримати значення властивості length без рядка або масиву.


// Метод slice() використовується для створення копії частини або всього рядка без зміни оригінального рядка. Він дозволяє витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий індекси.

str.slice(startIndex, endIndex);

// str — вихідний рядок, з якого робитиметься копія.
// startIndex — індекс, з якого починається копіювання елементів рядка.
// endIndex — індекс, до якого (не включаючи) йде копіювання елементів рядка.

// Метод slice() копіює підрядок із вихідного рядка, починаючи з індексу startIndex і до (не включаючи) індексу endIndex, і повертає цю копію як новий рядок.

const fullName = "Diana Dutko";
console.log(fullName.slice(0, 4)); // "Dian"
console.log(fullName.slice(3, 8)); // "na Du"
console.log(fullName.slice(2, fullName.length)); // "ana Dutko"

// Параметр endIndex є необов'язковим.
// Якщо endIndex не вказаний, витягуються всі елементи до кінця рядка.

console.log(fullName.slice(5)); // "a Dutko"
console.log(fullName.slice(9)); // "tko"

// Якщо викликати метод slice() без аргументів, він створює точну копію рядка і повертає її.

console.log(fullName.slice()); // "Diana Dutko"

// Результат виклику методу slice() можна зберігати в змінній для подальшого використання.

const fullname = "Diana Dutko";
const firstName = fullName.slice(0, 5);
const lastName = fullName.slice(6);

console.log(fullName); // "Diana Dutko"
console.log(firstName); // "Diana"
console.log(lastName); // "Dutko"

// Методи рядків toLowerCase() та toUpperCase() використовуються для зміни регістру символів у рядку. Обидва методи не змінюють вихідний рядок, а повертають новий рядок у відповідному регістрі.

// Метод toLowerCase() повертає новий рядок, у якому всі символи вихідного рядка перетворені в нижній регістр.

const greeting = 'Welcome to Monaco, Diana';
console.log(greeting.toLowerCase()); // 'welcome to monaco, diana'


// Метод toUpperCase() повертає новий рядок, у якому всі символи вихідного рядка перетворені у верхній регістр.

console.log(greeting.toUpperCase()); // "WELCOME TO MONACO, DIANA"

// При пошуку за ключовим словом, користувач вводить рядок 'saMsUng', а його треба порівняти з рядком 'samsung' або 'SAMSUNG'.

console.log('saMsUng' === 'samsung'); // false
console.log('saMsUng' === 'SAMSUNG'); // false

// Щоб не вимагати абсолютно точного введення, можна зробити «нормалізацію» введеного користувачем рядка, тобто перетворити всі його символи у верхній або нижній регістр.

const dreamCity = "portofino";
const input = "poRtofinO";
const lowercaseInput = input.toLowerCase();
console.log(dreamCity); // portofino
console.log(input); // poRtofinO
console.log(input === dreamCity); // false
console.log(lowercaseInput); // portofino
console.log(lowercaseInput === dreamCity); // true



// Метод рядків includes() використовується для перевірки наявності підрядка у рядку. Він повертає логічне значення true, якщо підрядок знайдено, і false, якщо підрядок відсутній.
// Синтаксис методу includes() виглядає так:
str.includes(substring)

// str — вихідний рядок, у якому ми шукаємо підрядок;
// substring — підрядок, який ми хочемо знайти у вихідному рядку.

const name = "Diana Dutko";
console.log(name.includes(Diana));


const username = 'Jacob Mercer';

console.log(username.includes('Jacob')); // true
console.log(username.includes('John')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('Doe')); // false

// Регістр символів у рядку й підрядку має значення. Літера a, наприклад, не дорівнює літері A.


console.log(username.includes('Jacob')); // true
console.log(username.includes('jacob')); // false
console.log(username.includes('Mercer')); // true
console.log(username.includes('mercer')); // false

// Метод includes() корисний, коли нам необхідно виконати зазначені дії за умови, коли рядок містить певний підрядок.

const msg = "Buy, please, buy our stuff!";
const hasSpam = msg.includes("buy");

if (hasSpam) {
  console.log("This site has spam!");
  
} else {
  console.log("This site is safe!");
  
}


// Методи startsWith() і endsWith() призначені для перевірки початку й закінчення рядка відповідно. Вони повертають булеве значення true або false, залежно від того, чи відповідає початок або кінець рядка заданому значенню.

// Метод startsWith() перевіряє, чи починається рядок із зазначеного підрядка.
str.startsWith(substr)

const str = "Hello, world!";

console.log(str.startsWith("Hello")); //true
console.log(str.startsWith("hello")); //false, ЧУТЛИВИЙ ДО РЕГІСТРУ

// Метод endsWith() перевіряє, чи закінчується рядок вказаним підрядком.
str.endsWith(substr)
// Він також приймає аргументом підрядок, присутність якого потрібно перевірити.

console.log(str.endsWith("World!")); //false, регістр
console.log(str.endsWith("rld!")); // true


// Обидва методи чутливі до регістру символів. Це означає, що під час порівняння підрядка з вихідним рядком регістр символів має збігатися. Якщо в ці методи не передати аргумент, то він повертає false.



// Метод indexOf() використовується для пошуку першого входження підрядка в рядок. Він повертає:

// індекс першого входження (індекс першого символу) підрядка, якщо він знайдений або
// -1, якщо підрядок не виявлено

str.indexOf(substr)

// str — вихідний рядок, у якому потрібно виконати пошук;
// substr — рядок, який потрібно знайти у вихідному рядку.

const mesage = "Welcome to Bahamas!";
const index = mesage.indexOf("to");
console.log(index);

// Якщо підрядок не знайдено, метод indexOf() поверне -1:

// Метод indexOf() корисний, коли тобі потрібно перевірити, чи містить рядок певний підрядок і отримати його індекс, якщо його знайдено. Цей метод в аргументи може приймати рядок або число. Якщо в аргументах буде число, то воно автоматично перетвориться у рядок. А якщо нічого не передати, то поверне число -1.



// Метод trim() використовується для видалення початкових і кінцевих пробілів із рядка. Це дозволяє "очистити" рядок від зайвих пробілів, наприклад під час обробки введення тексту користувачем в елементи форми, видаливши зайві пробіли, які могли бути додані випадково.

const birth = "     Nastya was born in May!      ";
const withoutSpaces = birth.trim();
console.log(birth);
console.log(withoutSpaces);

// Метод trim() не змінює вихідний рядок, а повертає новий рядок без початкових і кінцевих пробілів.




// Саме для багаторазового повторення однієї частини коду використовуються цикли.

// Цикл — керуюча конструкція, призначена для організації багаторазового виконання набору інструкцій.
// Тіло циклу — послідовність інструкцій, призначена для багаторазового виконання.
// Ітерація — одиничне виконання тіла циклу.
// Умова виходу — вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться.

// Конструкція while створює цикл, який виконує блок коду в тілі циклу, поки умова для виходу оцінюється як true.

while (condition) {
  statement;
}

// Умова обчислюється перед кожною ітерацією циклу.
// Якщо умова оцінюється як true, виконується код у тілі циклу (одна ітерація)
// Якщо умова оцінюється як false, виконання циклу переривається і скрипт продовжує виконувати інструкції після циклу


// Цикл while — це цикл з передумовою, тобто він виконується доки істинна певна умова, зазначена перед його початком. Цю умову перевіряють до виконання тіла циклу, тому тіло може бути не виконано жодного разу, якщо умова від самого початку хибна.

let count = 0;

while (count < 10) {
  console.log(`Count: ${count}`);
  count += 1;
}

// Цикл while виконуватиметься доки count менше 10. Щойно count стане рівним або більшим за 10, умова стане хибною, і цикл завершиться.


let visited = 60;
const isInEurasia = 94;

while (visited <= isInEurasia) {
  console.log(`You have ${isInEurasia - visited} more countries to visit!`);
  visited += 4;
}

// Цикл while часто використовується, коли точна кількість ітерацій заздалегідь не відома. Отже, цикл має виконуватися до виконання певної умови. Важливо дбати про те, щоб умова циклу while зрештою стала хибною, щоб уникнути нескінченного виконання.



// Цикли while і do...while працюють схожим чином, але мають одну ключову відмінність. Під час використання циклу do...while код у тілі циклу виконується принаймні один раз, навіть якщо умова не виконується з самого початку.

do {
  statement
} while (condition);

// Блок коду всередині do виконується в перший раз незалежно від виконання умови. Потім, після кожної ітерації, перевіряється умова. Якщо умова оцінюється як true, цикл продовжує виконуватися; якщо — як false, цикл завершується.

let Count = 0;

do {
  console.log(`Count: ${Count}`);
  Count += 1;
} while (Count > 5);

// У прикладі код усередині циклу do виконається один раз, навіть якщо count більше або дорівнює 5.

// Після цього умову буде перевірено, і якщо count менше 5, цикл продовжить виконуватися.

// Цикл do...while корисний, коли потрібно, щоб код у блоці виконався хоча б один раз, незалежно від умови.

// Цикл for також дозволяє виконувати код, що повторюється, багато разів. На відміну від циклів while і do…while, цикл for має змінну-лічильник. Змінна-лічильник оголошується за допомогою ключового слова let (оголошення через const видасть помилку). На кожній ітерації після виконання коду з тіла циклу вона змінює своє значення від заданого початкового до кінцевого з певним кроком.

for (initialization; condition; afterthought) {
  statement
}

// Ініціалізація — виконується один раз перед початком циклу. Тут оголошується змінна-лічильник і вказується її початкове значення.
// Умова — це вираз, який оцінюється перед кожною ітерацією (повторенням) циклу. Якщо умова перетворюється на true, то виконується тіло циклу. Якщо умова перетворюється на false, то цикл завершується.
// Пост-вираз — це вираз, який виконується в кінці кожної ітерації циклу, перед перевіркою умови. Використовується для оновлення значення змінної-лічильника.
// Тіло циклу — це блок коду, який буде виконуватися на кожній ітерації циклу, якщо умова перетворюється на true.


for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}

// У наведеному прикладі циклу for змінна i ініціалізується значенням 0. Цикл виконується доти, доки i менша або дорівнює 20. Після кожної ітерації значення i збільшується на 5. У результаті в консоль будуть виведені числа 0, 5, 10, 15 і 20.


// Також можна зробити зворотний відлік, змінивши умову і зменшуючи лічильник на якесь значення після кожної ітерації.

for (let x = 20; x >= 0; x -= 5) {
console.log(x);
}

// У наведеному прикладі циклу for змінна x ініціалізується значенням 20. Цикл виконується доти, доки x більше або дорівнює 0. Після кожної ітерації значення x зменшується на 5. У результаті в консоль будуть виведені числа 20, 15, 10, 5 і 0.


// Інкремент (++) і декремент (--) — це операції, які відповідно збільшують або зменшують значення числової змінної на одиницю і одразу ж зберігають оновлене значення у цій змінній. Існують два види інкременту та декременту: префіксний і постфіксний.

// Префіксний інкремент (++value) спочатку збільшує значення змінної, а потім використовує нове значення у виразі.

let z = 5;
const v = ++z;
console.log(z);
console.log(v);

// Постфіксний інкремент (value++) спочатку використовує поточне значення змінної у виразі, а потім виконує збільшення значення.

// Ці операції корисні, коли тобі потрібно змінювати значення змінних одразу на одиницю, що може бути важливо, наприклад, при створенні лічильників у циклах, замість комбінованих операторів += і -=.

for (let b = 2; b <= 10; b++) {
  console.log(b);
}

// У прикладі циклу for вище, змінна i ініціалізується значенням 0, і цикл виконується доти, доки i менше або дорівнює 5. Після кожної ітерації значення i збільшується на 1. У результаті в консоль будуть виведені числа від 0 до 5.


//
// Оператор break використовується в циклі для переривання його виконання. Коли оператор break зустрічається всередині циклу, виконання циклу негайно припиняється, і керування передається до наступної інструкції після циклу.

// Оператор break зазвичай використовується разом з умовними операторами або операторами порівняння всередині циклу, щоб перевіряти певну умову і, якщо вона виконується, переривати виконання циклу.

// Ось приклад використання оператора break у циклі for:

for (let i = 0; i < 10; i++) {
  console.log(i);
  
  if (i === 5) {
    console.log("met 5 - stop");
    break;
  }
}

// У цьому прикладі цикл for мав би виконуватися, доки значення змінної i менше 10. Але в тілі циклу є умова if (i === 5), яка перевіряє, чи дорівнює значення i числу 5. Коли ця умова стає істинною, тіло if виконується і застосовується оператор break, і виконання циклу припиняється. Таким чином, у консоль будуть виведені числа від 0 до 5 (включно), а цикл завершиться.



