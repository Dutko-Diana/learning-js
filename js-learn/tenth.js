// Внутрішній таймер-планувальник браузера дозволяє відкладати виклик функції на певний період часу. Для цього є тайм-аути та інтервали, вони контролюють, коли і як часто викликається функція. Таймери реалізовані в браузері, а не вбудовані в мову, і доступні на глобальному об'єкті window.

// Метод setTimeout() дозволяє запланувати одноразовий виклик функції через певний час.

const timerId = setTimeout(callback, delay, arg1, arg2, ...);

// callback — функція, виклик якої необхідно запланувати;
// delay — час у мілісекундах, через який callback-функція буде викликана один раз.

// Додаткові аргументи (arg1, arg2 тощо) не обов’язкові і будуть передані callback функції під час виклику. Результатом виклику setTimout() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.


// Метод setInterval() — це простий спосіб повторення коду знову і знову з певним інтервалом.

// Синтаксис і параметри такі самі, як у setTimeout().

const intervalId = setInterval(callback, delay, arg1, arg2, ...);

// Результатом виклику setInterval() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.

// На відміну від setTimeout(), інтервал запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу.


// Екземпляр класу Date — це об'єкт, що відображає певний момент часу. Створення дати без аргументів повертає об'єкт, що зберігає дату і час на момент його ініціалізації, тобто поточні дату і час.

const date = new Date();

console.log(date); // "Fri Jun 18 2021 15:01:35 GMT+0300 (Eastern European Summer Time)"

// У рядковому перетворенні об'єкт повертає результат виклику вбудованого методу toString(), тому у першому лозі ми отримаємо рядок, а не об'єкт.

// Створюючи екземпляр класу Date, можна налаштувати різні формати відображення даних. Нижче приклад, де до класу Date передають рядок, який описує тільки дату.

const date = new Date("2030-03-16");
console.log(date); // "Sat Mar 16 2030 00:00:00 GMT+0200"

// Тут до Date передали рядок, де дата і час розділяються великою літерою T (time).

const date = new Date("2030-03-16T14:25:00");
console.log(date); // "Sat Mar 16 2030 14:25:00 GMT+0200"

// Як ти бачиш, формат рядка, переданого до Date, дуже гнучкий.

// Можна передати тільки рік, рік і місяць, або повну дату, включно з числом і часом.

console.log(new Date("2030")); // "Tue Jan 01 2030 02:00:00 GMT+0200"
console.log(new Date("2030-03")); // "Fri Mar 01 2030 02:00:00 GMT+0200"
console.log(new Date("2030-03-16")); // "Sat Mar 16 2030 02:00:00 GMT+0200"
console.log(new Date("2030-03-16T14:25:00")); // "Sat Mar 16 2030 14:25:00 GMT+0200"

// Інший спосіб створення нової дати — це передати сім чисел, які описують рік, місяць (починається з 0), день, години, хвилини, секунди й мілісекунди. Обов'язкові тільки перші три.

const date = new Date(2030, 2, 16, 14, 25, 0, 0);
console.log(date); // "Sat Mar 16 2030 14:25:00 GMT+0200 "


// Для комп’ютерів відлік часу рахується в мілісекундах, що минули після опівночі 1 січня 1970 року в часовому поясі UTC (Coordinated Universal Time). Це — Unix час.

// Під час ініціалізації дати одним числом, воно являє собою кількість мілісекунд, що вже минула з 01.01.1970.

// Вбудований метод getTime() повертає числове значення цієї дати (timestamp) — кількість мілісекунд, що минула з півночі 1 січня 1970 року.


// Метод Date.now()

// У разі, коли все, що потрібно, це числове представлення моменту часу, немає сенсу створювати цілий об'єкт. Можна використовувати метод Date.now() — це швидкий і зручний спосіб отримати поточний час у вигляді мілісекунд


// Promise (проміс, від англ. promise — обіцяти) — об'єкт, що представляє поточний стан асинхронної операції. Це обгортка для значення, невідомого на момент створення промісу. Проміс дозволяє обробляти результати асинхронних операцій таким чином, якби вони були синхронними: замість кінцевого результату асинхронної операції, повертається своєрідна обіцянка отримати результат у майбутньому.

// Проміс може бути у трьох станах:

// Очікування (pending) — початковий стан під час створення промісу.
// Виконано (fulfilled) — операція виконана успішно з будь-яким результатом.
// Відхилено(rejected) — операція відхилена з помилкою.

//     Коли проміс переходить у стан fulfilled або rejected — це назавжди.

// Коли проміс виконаний або відхилений, використовується термін settled. Це не окремий стан, а лише спосіб описати, що проміс перебуває в будь-якому стані, крім очікування.

const isSuccess = 0;

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (isSuccess) {
      resolve('Success!');
    } else {
      reject('Error!');
    }
  }, 2000)
});

promise
  .then((value) => {
    console.log(value);
  })
  .catch(error => console.log(error))
    .finally(() => { console.log('settled') });
  

    
//     Промісифікація — це перетворення функції з колбеками таким чином, щоб вона не приймала колбеки, а повертала проміс. Така функція називається промісифікована.

// Відмінності промісу і callback-функції:

// Колбеки — це функції, проміси — це об'єкти.
// Колбеки передаються як аргументи функції, що виконує асинхронну операцію, а проміси створюються всередині цієї функції і повертаються як її результат.
// Колбеки обробляють успішне або неуспішне завершення операції, проміси нічого не обробляють, тільки зберігають поточний стан асинхронної операції.
// Колбеки можуть обробляти декілька подій, проміси пов'язані тільки з однією подією.


// Promise.resolve() і Promise.reject() — це статичні методи для створення промісів, що миттєво успішно виконуються або відхиляються. Вони працюють аналогічно new Promise(), повертають проміс, але мають коротший синтаксис.

// Так створюється успішно виконаний проміс через new Promise():

new Promise(resolve => resolve("success value"))
	.then(value => console.log(value));
	.catch(error => console.log(error));

// Так створюється успішно виконаний проміс через Promise.resolve():

Promise.resolve("success value");
	.then(value => console.log(value));
	.catch(error => console.log(error));

// Так створюється проміс, що виконався з помилкою через new Promise():

new Promise((resolve, reject) => reject("error"));
	.then(value => console.log(value));
	.catch(error => console.log(error));

// Так створюється проміс, що виконався з помилкою через Promise.reject():

Promise.reject("error");
	.then(value => console.log(value));
	.catch (error => console.log(error));
  

  // Є ситуації, коли потрібно чекати на виконання всіх промісів одночасно, а потім обробляти їх результати. Або ситуації, коли достатньо дочекатися виконання хоча б одного з них, ігноруючи інші випадки. Для цих сценаріїв клас Promise має статичні методи для роботи з групою промісів.

// Метод Promise.all() дозволяє одночасно обробити кілька промісів та отримати їхні результати. Він приймає масив промісів як вхідні дані, чекає їх виконання та повертає один проміс.

Promise.all([promise1, promise2, promise3, ...])

// Якщо всі проміси виконуються успішно, повернений проміс перейде у стан fulfilled, а його значенням буде масив результатів виконання кожного промісу.

const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
	.then(values => console.log(values)); // [1, 2, 3]
	.catch (error => console.log(error));
  
// Якщо хоча б один із промісів відхиляється, повернений проміс одразу переходить у стан rejected, а його значенням буде помилка.

const p1 = Promise.resolve(1);
const p2 = Promise.reject("Rejected promise 2");
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
	.then(values => console.log(values))
	.catch(error => console.log(error)); // "Rejected promise 2"


  // Метод Promise.allSettled() також дозволяє одночасно обробити кілька промісів та отримати їхні результати. Він приймає масив промісів як вхідні дані, чекає їх виконання та повертає один проміс.

Promise.allSettled([promise1, promise2, promise3, ...])

// Відмінність від Promise.all полягає в тому, що метод Promise.allSettled() чекає виконання всіх промісів незалежно від того, чи були деякі або навіть всі проміси відхилені.

// Повернутий проміс ніколи не буде відхилений, він завжди успішно виконується (стан fulfilled). Додавання методу catch навіть не має сенсу, оскільки він ніколи не виконається.


// Метод Promise.race приймає масив промісів і повертає "найшвидший", тобто перший виконаний або відхилений проміс з переданих, разом зі значенням або причиною його відхилення.

Promise.race([promise1, promise2, promise3, ...])
