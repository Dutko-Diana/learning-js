'use strict';
// виводить дані в дужках в консоль
console.log("Buongiorno! Come va?");

// оголошення змінних

// const age = 20;
// const username = "Diana";

// const - ключове слово (ще є let), age i username - імена змінних, = оператор присвоєння, ; обов'язково вкінці кожного рядка

const age = 36;
console.log(age);
let username = "Mango";
console.log(username);
username = "Dutko";
console.log(username);

// можна не задавати знвчення першій змінній з let

let userdate;
console.log(userdate);
userdate = 25;
console.log(userdate);

// Правило використання const та let може бути таким: — Використовуй const за замовчуванням для оголошення змінних. — Використовуй let, якщо потрібно змінювати значення змінної під час виконання скрипту. Це правило допоможе писати більш надійний, зрозумілий код, який легко підтримувати.


// значення змінної null означає, що змінна немає даних взагалі:
const userName = null;
console.log(userName);

// Значення undefined вказує на невизначеність значення змінної, тобто каже нам, що значення на даний момент невідоме чи невизначене:
let value;
console.log(value);

// Оператор typeof використовується для визначення типу даних значення або виразу. 
typeof operand
// Замість operand вказувати змінну, літерал або вираз, тип якого ти хочеш визначити. Результатом оператора typeof буде рядок, який вказує тип даних.

console.log(typeof userName); виведе тип даних змінної userName

// Оператор (%) повертає остачу від ділення одного числа на інше.
const x = 8;
const y = 6;
console.log(x % y);

// Оператор (**) використовується для піднесення числа до степеня.

const z = 8;
const f = 5;
console.log(z ** f); // 32768


// Додавання: +=. Приклад: x += y еквівалентно x = x + y

// Віднімання: -=.Приклад: x -= y еквівалентно x = x - y

// Множення: *=.Приклад: x *= y еквівалентно x = x * y

// Ділення: /=. Приклад: x / = y еквівалентно x = x / y

// Остача від ділення: %=. Приклад: x %= y еквівалентно x = x % y


let userAge = 17;
userAge = userAge + 1;
console.log(userAge);

// or

let UserAge = 17;
UserAge += 1;
console.log(UserAge);


// Якщо застосувати оператор + до рядка та будь-якого іншого типу даних, результатом буде новий рядок, що містить об'єднання вихідних значень. Це називається конкатенація (склеювання).

const message = "Diana " + "ama " + "l'Italia!";
console.log(message); // "Diana ama l'Italia!"

// Під час конкатенації можна використовувати значення змінних, щоб складати рядки з динамічними значеннями. Для цього необхідно вказати ім'я змінної, у це місце буде підставлено її значення.

const pet = "cane";
console.log("Diana ha uno" + pet);

// Проте порядок операндів має значення. Перетворення типів відбувається лише в момент операції додавання з рядком. До цього моменту застосовуються нормальні правила математики.

console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"


// Явне перетворення типів виконується програмістом і використовується за потребою. Для перетворення будь-якого значення на рядок можна використовувати вбудовану функцію String(), яка повертає результат у вигляді рядка.

console.log(String(5)); // "5"
console.log(String(true)); // "true"
console.log(String(false)); // "false"
console.log(String(null)); // "null"
console.log(String(undefined)); // "undefined"


// Неявне перетворення типів відбувається автоматично під час виконання операцій або обчислень.

console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"


// Шаблонні рядки — це синтаксис, який полегшує об'єднання статичного тексту з динамічним (тобто текстом, що містить змінні, обчислення тощо). Шаблонні рядки огортаються зворотними лапками (англ. backticks) (``)

const questName = "Diana";
const hotelName = "Hotel de Paris Monte-Carlo";
const greeting = `Welcome to ${hotelName}, ${questName}!`;
console.log(greeting);


// Для доступу до властивості (property) сутності (objectName) використовується синтаксис із крапкою: сутність.властивість
// Довжина рядка визначається кількістю символів у ньому. Щоб дізнатися довжину рядка, використовується вбудована властивість length. Щоб отримати значення цієї властивості, необхідно звернутися до неї через крапку після імені змінної чи рядкового літералу.

const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12


// Для доступу до певного символу рядка ми використовуємо синтаксис квадратних дужок, де вказуємо індекс потрібного символу: string[index], тобто рядок[індекс].

const product = "Tickets to Monaco";
console.log(product[3]); //k
console.log(product[6]); //s
console.log(product[14]); //a

// Отримання останнього символу рядка можливе за його індексом string[lastIndex]. Щоб знайти індекс останнього символу рядка, треба від довжини цього рядка відняти одиницю string.length - 1

let city = 'Monte-Carlo';
const lastElementIndex = city.length - 1;
console.log(city[lastElementIndex]); //o

// Для доступу до останнього символу рядка без створення проміжної змінної ми можемо вставити вираз (product.length - 1) безпосередньо у квадратні дужки при зверненні до елемента.

city = 'Portofino';
console.log(city[city.length - 1]); //o


// Коли рядок створюється, він зберігає своє значення і стає незмінним. Це означає, що не можна замінити окремі символи всередині рядка.

let Product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
Product[2] = "O";
console.log(product); // "Droid"


// Натомість ми повинні створити новий рядок і присвоїти його змінній замість старого рядка.

let country = 'Ukraine';
console.log(country); //Ukraine

country = 'UKraine';
console.log(country); //UKraine


// Ось деякі основні оператори порівняння:

// Оператор > (більше) — повертає true, якщо лівий операнд більше правого. В іншому разі повертає false .

// Оператор < (менше) — повертає true, якщо лівий операнд менше правого. В іншому разі повертає false .

// Оператор >= (більше або дорівнює) — повертає true, якщо лівий операнд більше або дорівнює правому. Якщо навпаки, повертає false .

// Оператор <= (менше або дорівнює) — повертає true, якщо лівий операнд менше або дорівнює правому. Якщо навпаки, повертає false .

const a = 2;
const b = 5;

console.log(a > b); // false
console.log(b > a); // true
console.log(a >= b); // false
console.log(b >= a); // true

console.log(a < b); // true
console.log(b < a); // false
console.log(a <= b); // true
console.log(b <= a); // false

// Оператори порівняння часто використовуються в умовних виразах або циклах, про які дізнаєшся пізніше, для перевірки умов та виконання певних дій на основі результатів порівняння. Наприклад, користувачі, старші за 18 років, отримують доступ до певної групи товарів.

const Age = 16;
const isAdult = Age >= 18;
console.log(isAdult);


// Оператори несуворої рівності:

// Оператор == (дорівнює) — порівнює два значення на рівність і повертає true, якщо значення операндів рівні. Якщо навпаки, повертає false

// Оператор != (не дорівнює) — порівнює два значення на нерівність і повертає true, якщо значення операндів не рівні. Якщо навпаки, повертає false

console.log(3 == 7); //false
console.log(7 == 7); //true
console.log(3 != 7); //true
console.log(3 != 3); //false

// Для уникнення таких проблем рекомендується використовувати оператори суворої рівності, які не виконують перетворення типів операндів.

// Оператор === (сувора рівність) — порівнює два значення на рівність, повертає true, якщо значення операндів рівні та мають однаковий тип даних. В іншому випадку, повертає false

// Оператор !== (сувора нерівність) — порівнює два значення на нерівність, повертає true, якщо значення операндів не рівні або мають різні типи даних. В іншому випадку, повертає false

// Добре, приведення типів не виконується
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true



// У деяких операціях виконується явне або неявне перетворення значень операндів до числа. Для явного перетворення будь-якого значення в число можна використовувати вбудовану функцію Number(), яка повертає результат у вигляді числа.

console.log(Number('4')); //4
console.log(Number(true)); //1
console.log(Number(false)); //0
console.log(Number(null)); //0


// Якщо неможливо привести значення до числа, результатом перетворення буде спеціальне значення NaN (Not a Number). Ось кілька прикладів, коли результатом перетворення буде NaN.

console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN


// Арифметичні операції (+, -, *, /) виконують неявне перетворення типів.

console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4

// Якщо у виразі присутній хоча б один із операндів з типом рядка, то обидва операнди приводяться до чисел. Це відбувається у всіх арифметичних операціях, окрім додавання. Пам’ятай, що + біля рядкових операндів викликає їх з'єднання (конкатинацію).

// Для всіх інших типів операндів та операцій виконується перетворення операндів до числа.

console.log("10" > 5); // true
console.log(10 > "5"); // true
console.log(5 > true); // true
console.log(5 < true); // false
console.log("5" < true); // false



// Метод Number.parseInt() приймає 2 аргументи:

// Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений у рядок
// Система числення, до якої відноситься рядок (не обов’язковий аргумент, за замовчуванням десяткова система). Наприклад, для десяткової системи буде 10, для шістнадцяткової - 16 тощо..

// Метод аналізує рядок зліва направо, видаляючи пробіли на початку і перетворюючи допустимі символи у число до тих пір, поки не зіткнеться з першим недопустимим символом. Після цього аналіз припиняється, і вже перетворене ціле число повертається.

console.log(Number.parseInt("5")); //5
console.log(Number.parseInt("5.5")); //5
console.log(Number.parseInt("12qwe74")); //12
console.log(Number.parseInt("12.46qwe79")); // 12 
console.log(Number.parseInt("cm5")); // NaN 
console.log(Number.parseInt("")); // NaN 
console.log(Number.parseInt("qweqwe")); // NaN

// Якщо перші символи рядка не можуть бути перетворені на число, або рядок порожній чи відсутній, результатом буде значення NaN (Not a Number).


// Метод Number.parseFloat() аналогічний Number.parseInt() з однієї відмінністю: перетворює рядок на число з плаваючою крапкою.
console.log(Number.parseFloat("5")); //5
console.log(Number.parseFloat("5.5")); //5.5
console.log(Number.parseFloat("3.14")); //3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN

const Value = "24.5px";
const numerical = Number.parseFloat(Value);
console.log(numerical);