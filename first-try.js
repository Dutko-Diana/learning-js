'use strict';
// виводить дані в дужках в консоль
console.log("Buongiorno! Come va?");

// оголошення змінних

// const age = 20;
// const username = "Diana";

// const - ключове слово (ще є let), age i username - імена змінних, = оператор присвоєння, ; обов'язково вкінці кожного рядка

const age = 36;
console.log(age);
let username = "Mango";
console.log(username);
username = "Dutko";
console.log(username);

// можна не задавати знвчення першій змінній з let

let userdate;
console.log(userdate);
userdate = 25;
console.log(userdate);

// Правило використання const та let може бути таким: — Використовуй const за замовчуванням для оголошення змінних. — Використовуй let, якщо потрібно змінювати значення змінної під час виконання скрипту. Це правило допоможе писати більш надійний, зрозумілий код, який легко підтримувати.


// значення змінної null означає, що змінна немає даних взагалі:
const userName = null;
console.log(userName);

// Значення undefined вказує на невизначеність значення змінної, тобто каже нам, що значення на даний момент невідоме чи невизначене:
let value;
console.log(value);

// Оператор typeof використовується для визначення типу даних значення або виразу. 
typeof operand
// Замість operand вказувати змінну, літерал або вираз, тип якого ти хочеш визначити. Результатом оператора typeof буде рядок, який вказує тип даних.

console.log(typeof userName); //виведе тип даних змінної userName

// Оператор (%) повертає остачу від ділення одного числа на інше.
const x = 8;
const y = 6;
console.log(x % y);

// Оператор (**) використовується для піднесення числа до степеня.

const z = 8;
const f = 5;
console.log(z ** f); // 32768


// Додавання: +=. Приклад: x += y еквівалентно x = x + y

// Віднімання: -=.Приклад: x -= y еквівалентно x = x - y

// Множення: *=.Приклад: x *= y еквівалентно x = x * y

// Ділення: /=. Приклад: x / = y еквівалентно x = x / y

// Остача від ділення: %=. Приклад: x %= y еквівалентно x = x % y


let userAge = 17;
userAge = userAge + 1;
console.log(userAge);

// or

let UserAge = 17;
UserAge += 1;
console.log(UserAge);


// Якщо застосувати оператор + до рядка та будь-якого іншого типу даних, результатом буде новий рядок, що містить об'єднання вихідних значень. Це називається конкатенація (склеювання).

const message = "Diana " + "ama " + "l'Italia!";
console.log(message); // "Diana ama l'Italia!"

// Під час конкатенації можна використовувати значення змінних, щоб складати рядки з динамічними значеннями. Для цього необхідно вказати ім'я змінної, у це місце буде підставлено її значення.

const pet = "cane";
console.log("Diana ha uno" + pet);

// Проте порядок операндів має значення. Перетворення типів відбувається лише в момент операції додавання з рядком. До цього моменту застосовуються нормальні правила математики.

console.log(1 + "2"); // "12"
console.log(1 + "2" + 4); // "124"
console.log(1 + 2 + "4"); // "34"


// Явне перетворення типів виконується програмістом і використовується за потребою. Для перетворення будь-якого значення на рядок можна використовувати вбудовану функцію String(), яка повертає результат у вигляді рядка.

console.log(String(5)); // "5"
console.log(String(true)); // "true"
console.log(String(false)); // "false"
console.log(String(null)); // "null"
console.log(String(undefined)); // "undefined"


// Неявне перетворення типів відбувається автоматично під час виконання операцій або обчислень.

console.log("5" + 3); // "53"
console.log("5" + true); // "5true"
console.log("5" + false); // "5false"
console.log("5" + null); // "5null"
console.log("5" + undefined); // "5undefined"


// Шаблонні рядки — це синтаксис, який полегшує об'єднання статичного тексту з динамічним (тобто текстом, що містить змінні, обчислення тощо). Шаблонні рядки огортаються зворотними лапками (англ. backticks) (``)

const questName = "Diana";
const hotelName = "Hotel de Paris Monte-Carlo";
const greeting = `Welcome to ${hotelName}, ${questName}!`;
console.log(greeting);


// Для доступу до властивості (property) сутності (objectName) використовується синтаксис із крапкою: сутність.властивість
// Довжина рядка визначається кількістю символів у ньому. Щоб дізнатися довжину рядка, використовується вбудована властивість length. Щоб отримати значення цієї властивості, необхідно звернутися до неї через крапку після імені змінної чи рядкового літералу.

const productName = "Repair droid";

// Якщо у змінній зберігається рядок
console.log(productName.length); // 12

// Якщо рядковий літерал
console.log("Repair droid".length); // 12


// Для доступу до певного символу рядка ми використовуємо синтаксис квадратних дужок, де вказуємо індекс потрібного символу: string[index], тобто рядок[індекс].

const product = "Tickets to Monaco";
console.log(product[3]); //k
console.log(product[6]); //s
console.log(product[14]); //a

// Отримання останнього символу рядка можливе за його індексом string[lastIndex]. Щоб знайти індекс останнього символу рядка, треба від довжини цього рядка відняти одиницю string.length - 1

let city = 'Monte-Carlo';
const lastElementIndex = city.length - 1;
console.log(city[lastElementIndex]); //o

// Для доступу до останнього символу рядка без створення проміжної змінної ми можемо вставити вираз (product.length - 1) безпосередньо у квадратні дужки при зверненні до елемента.

city = 'Portofino';
console.log(city[city.length - 1]); //o


// Коли рядок створюється, він зберігає своє значення і стає незмінним. Це означає, що не можна замінити окремі символи всередині рядка.

let Product = "Droid";
console.log(product); // "Droid"

// Це не має жодного ефекту
Product[2] = "O";
console.log(product); // "Droid"


// Натомість ми повинні створити новий рядок і присвоїти його змінній замість старого рядка.

let country = 'Ukraine';
console.log(country); //Ukraine

country = 'UKraine';
console.log(country); //UKraine


// Ось деякі основні оператори порівняння:

// Оператор > (більше) — повертає true, якщо лівий операнд більше правого. В іншому разі повертає false .

// Оператор < (менше) — повертає true, якщо лівий операнд менше правого. В іншому разі повертає false .

// Оператор >= (більше або дорівнює) — повертає true, якщо лівий операнд більше або дорівнює правому. Якщо навпаки, повертає false .

// Оператор <= (менше або дорівнює) — повертає true, якщо лівий операнд менше або дорівнює правому. Якщо навпаки, повертає false .

const a = 2;
const b = 5;

console.log(a > b); // false
console.log(b > a); // true
console.log(a >= b); // false
console.log(b >= a); // true

console.log(a < b); // true
console.log(b < a); // false
console.log(a <= b); // true
console.log(b <= a); // false

// Оператори порівняння часто використовуються в умовних виразах або циклах, про які дізнаєшся пізніше, для перевірки умов та виконання певних дій на основі результатів порівняння. Наприклад, користувачі, старші за 18 років, отримують доступ до певної групи товарів.

const Age = 16;
const isAdult = Age >= 18;
console.log(isAdult);


// Оператори несуворої рівності:

// Оператор == (дорівнює) — порівнює два значення на рівність і повертає true, якщо значення операндів рівні. Якщо навпаки, повертає false

// Оператор != (не дорівнює) — порівнює два значення на нерівність і повертає true, якщо значення операндів не рівні. Якщо навпаки, повертає false

console.log(3 == 7); //false
console.log(7 == 7); //true
console.log(3 != 7); //true
console.log(3 != 3); //false

// Для уникнення таких проблем рекомендується використовувати оператори суворої рівності, які не виконують перетворення типів операндів.

// Оператор === (сувора рівність) — порівнює два значення на рівність, повертає true, якщо значення операндів рівні та мають однаковий тип даних. В іншому випадку, повертає false

// Оператор !== (сувора нерівність) — порівнює два значення на нерівність, повертає true, якщо значення операндів не рівні або мають різні типи даних. В іншому випадку, повертає false

// Добре, приведення типів не виконується
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(5 !== "5"); // true
console.log(5 !== 5); // false
console.log(1 === true); // false
console.log(1 !== true); // true



// У деяких операціях виконується явне або неявне перетворення значень операндів до числа. Для явного перетворення будь-якого значення в число можна використовувати вбудовану функцію Number(), яка повертає результат у вигляді числа.

console.log(Number('4')); //4
console.log(Number(true)); //1
console.log(Number(false)); //0
console.log(Number(null)); //0


// Якщо неможливо привести значення до числа, результатом перетворення буде спеціальне значення NaN (Not a Number). Ось кілька прикладів, коли результатом перетворення буде NaN.

console.log(Number(undefined)); // NaN
console.log(Number("Jacob")); // NaN
console.log(Number("25px")); // NaN


// Арифметичні операції (+, -, *, /) виконують неявне перетворення типів.

console.log("5" * 2); // 10
console.log("10" - 5); // 5
console.log(5 + true); // 6
console.log(5 - true); // 4

// Якщо у виразі присутній хоча б один із операндів з типом рядка, то обидва операнди приводяться до чисел. Це відбувається у всіх арифметичних операціях, окрім додавання. Пам’ятай, що + біля рядкових операндів викликає їх з'єднання (конкатинацію).

// Для всіх інших типів операндів та операцій виконується перетворення операндів до числа.

console.log("10" > 5); // true
console.log(10 > "5"); // true
console.log(5 > true); // true
console.log(5 < true); // false
console.log("5" < true); // false



// Метод Number.parseInt() приймає 2 аргументи:

// Рядок. Якщо аргумент не є рядком, то він буде спочатку перетворений у рядок
// Система числення, до якої відноситься рядок (не обов’язковий аргумент, за замовчуванням десяткова система). Наприклад, для десяткової системи буде 10, для шістнадцяткової - 16 тощо..

// Метод аналізує рядок зліва направо, видаляючи пробіли на початку і перетворюючи допустимі символи у число до тих пір, поки не зіткнеться з першим недопустимим символом. Після цього аналіз припиняється, і вже перетворене ціле число повертається.

console.log(Number.parseInt("5")); //5
console.log(Number.parseInt("5.5")); //5
console.log(Number.parseInt("12qwe74")); //12
console.log(Number.parseInt("12.46qwe79")); // 12 
console.log(Number.parseInt("cm5")); // NaN 
console.log(Number.parseInt("")); // NaN 
console.log(Number.parseInt("qweqwe")); // NaN

// Якщо перші символи рядка не можуть бути перетворені на число, або рядок порожній чи відсутній, результатом буде значення NaN (Not a Number).


// Метод Number.parseFloat() аналогічний Number.parseInt() з однієї відмінністю: перетворює рядок на число з плаваючою крапкою.
console.log(Number.parseFloat("5")); //5
console.log(Number.parseFloat("5.5")); //5.5
console.log(Number.parseFloat("3.14")); //3.14
console.log(Number.parseFloat("5cm")); // 5
console.log(Number.parseFloat("5.5cm")); // 5.5
console.log(Number.parseFloat("12qwe74")); // 12
console.log(Number.parseFloat("12.46qwe79")); // 12.46
console.log(Number.parseFloat("cm5")); // NaN
console.log(Number.parseFloat("")); // NaN
console.log(Number.parseFloat("qweqwe")); // NaN

const Value = "24.5px";
const numerical = Number.parseFloat(Value);
console.log(numerical);


// Math.floor(num): повертає найближче ціле число, яке є меншим або дорівнює вказаному числу num. Наприклад:

console.log(Math.floor(1.4)); //1
console.log(Math.floor(1.9)); //1

// Math.ceil(num): повертає найближче ціле число, яке є більшим, або дорівнює зазначеному числу num. Наприклад:

console.log(Math.ceil(1.4)); //2
console.log(Math.ceil(2.5)); //3

// Math.round(num): повертає значення числа після округлення до найближчого цілого. Округлення відбувається за математичними правилами, якщо десяткова частина числа менша 0.5, то округлення буде в меншу сторону, якщо 0.5 і більше — то в більшу. Наприклад:

console.log(Math.round(1.3)); //1
console.log(Math.round(5.8)); //6

// Math.max(num1, num2, ...): повертає найбільше число з набору переданих чисел. Наприклад:

console.log(Math.max(27, 37, 73, 8)); //73

// Math.min(num1, num2, ...): повертає найменше число з набору переданих чисел. Наприклад:

console.log(Math.min(28, 49, 77, 93));//28

// Math.random(): повертає випадкове число в діапазоні від 0 (включно) до 1 (за винятком). Наприклад:

console.log(Math.random()); // випадкове число між 0 і 1, наприклад 0.2 ... 0.9166353649342294


// Дробове число
// Підхід 1.
  // Помножити числа на досить велике число (наприклад, 10 або 100).
  // Виконати додавання.
  // Розділити результат на те саме число, щоб повернути його до початкового масштабу.

console.log(0.1 * 10 + 0.2 * 10); // 3
console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3

// Підхід 2.
// Використовувати метод числа toFixed() для округлення результату до певної кількості знаків після крапки.

console.log((0.1 + 0.2).toFixed(1)); //0.3
console.log((6).toFixed(2)); //6.00
console.log((4.7287382).toFixed(4)); //4.7287

// Метод toFixed() повертає рядок, що представляє число із зазначеною кількістю знаків після крапки. Таким чином, ми можемо отримати заокруглений результат з необхідною точністю.


// Оголошення функції має таку структуру:

// Ключове слово function
// Ім'я функції — це дієслово, що відповідає на питання "Що зробити?"
// Пара круглих дужок ()
// Тіло функції у фігурних дужках {}

function doStuff() {
    console.log('what needs to be done');
}

// Коли функцію потрібно виконати, вона викликається за допомогою її імені та пари круглих дужок.

doStuff(); // 'what needs to be done'
doStuff(); // 'what needs to be done'
doStuff(); // 'what needs to be done'


// У круглих дужках після імені функції вказуються параметри. Параметри є перерахуванням даних, які очікує функція під час виклику. Параметри — це локальні змінні, доступні лише всередині тіла функції. Параметри розділяються комами. Функція може мати будь-яку кількість параметрів або не мати їх взагалі, у такому випадку вказуються просто порожні круглі дужки.

function multiply(x, y, z) {
    console.log(`The rusult is: ${x * y * z}`);
}

// Під час виклику функції в круглих дужках можна передати аргументи, які є значеннями для оголошених параметрів функції.

multiply(2, 3, 5); // "Result: 30"
multiply(4, 8, 12); // "Result: 384"
multiply(17, 6, 25); // "Result: 2550"


function add(a, b, c) {
    console.log( `Addition result equals ${a + b + c}`);
}

add(15, 27, 10);
add(10, 20, 30);
add(5, 10, 15);


// Оператор return використовується для повернення значення з тіла функції назад у код, у місце її виклику. Коли інтерпретатор зустрічає оператор return, він негайно виходить із функції (припиняє її виконання) і повертає вказане після return значення в місце виклику функції.

function multiply(x, y, z) {
    const result = x * y * z;
    return result
}

// Результат роботи функції можна зберегти у змінну
const product = multiply(2, 3, 5);
console.log(product);

// Щоб уникнути оголошення зайвої змінної в тілі функції, можна відразу ж повертати результат виразу. Так, немає необхідності створювати окрему змінну для зберігання результату виразу.

function multiply(x, y, z) {
    return x * y * x;
}

const result = multiply(3, 5, 1);
console.log(result);


//Якщо в тілі функції відсутній оператор return або він не вказує на конкретне значення, функція поверне спеціальне значення undefined.

function multiply(x, y, z) {
	const product = x * y * z;
}

const Result = multiply(2, 3, 5);
console.log(result); // undefined


// При використанні оператора return всі інструкції, які йдуть на рядках після нього, в тілі функції не виконуються, оскільки виконання функції припиняється відразу після зустрічі оператора return.

function multiply(x, y, z) {
  console.log('The code before return is executed as usual');

  return x * y * z;

  console.log('This code is never executed because it is after return');
}

console.log(multiply(2, 3, 5)); // 30



function add(a, b, c) {
return a + b + c;
}


